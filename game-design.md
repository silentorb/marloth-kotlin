# Game Design

## Growth

Growth in games is fun.  It gives players a heightened sense of accomplishment, and it can be used to morph game mechanics over the course of a game session.

Growth is most fun when it is unbridled, except that it is hard to maintain balance with unbridled growth.  If balance is lost then the game loses much of its fun.

Unbridled growth creates a growth curve.  The growth curve outlines the median rate of growth a player can progress along which will maintain a balanced challenge.  If the player gets ahead of the curve the game loses its challenge.  If the player falls behind the curve the game becomes more challenging to the point of impossibility.

What's more, a growth curve is exponential.  Riches beget more riches and debts beget more debts.  If the player can get slightly ahead of the curve early on, that will grant them an edge to get even further ahead later.  Conversely, falling behind a little means increasing missed opportunities later.

Most games do not have unbridled growth.  Most games use one or more methods to restrict growth.  The primary methods for restricting growth are:

### Grinding

Rewarding the player for labor instead of skill.  I don't like grinding and want to avoid it in any game I make with one exception, grinding can sometimes be a useful *fallback*Â as long as its possible to bypass the grinding with enough skill.

### Check point limits

This only works for games that are broken up into stages.  Each stage has a limit to how much a character can grow.  This is a better method than grinding but still greatly cheapens the sense of growth in the game.

### Fixed growth

Taking "Check point limits" a step further, some games have fixed growth, in that the character is hard-coded to grow in specific ways at different stages of the game.  This method is especially common in FPS campaigns, where at different stages the player will be given new and better weapons as part of the story.  Acquiring the new weapon often is not even an option, in which case the player cannot progress through the story until the weapon is picked up.

### Scaling loss

This is less common but also one of the more interesting and healthy approaches.  It plays on the notion of "the bigger they are the harder they fall."  With this method, if a player gets ahead of the growth curve, he loses far more if he fails in any way, while someone below the growth curve will struggle more, but has less to lose.

### Auto-scaling enemies
If the player does really well, the game increases the challenge.  This is a cheap option and is rarely employed.

### Diminishing returns

By itself this does not bridle growth, but can help soften the effects of players getting ahead of the growth curve.

### Ceilings

Diminishing returns and ceilings are basically the same principle, just different math.  This is different from check point limits in that this is a global ceiling, independent of what stage of the game the player is at.  It is next to impossible to balance a game with no ceilings.  Having no cap can cause infinite, unpredictable problems.  Not only does it provide logistical problems, but it also provides technical problems, in that a computer is a finite machine and while a game could officially support a player character reaching level 6 trillion, that wouldn't be practical.

### No growth feedback loop
Basically, if a game avoids rewarding growth with more growth.  Implementing this is actually standard for most genres except strategy games.  

### Shortcuts

### Some challenges not effected by growth

One classic case of this is platform games with role playing elements.  The game may allow upgrading your weapons to make it easier to fight enemies, but doesn't feature any upgrades to make a jumping sequence any easier.

### Fake growth / micro growth

